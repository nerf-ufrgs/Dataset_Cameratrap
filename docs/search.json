[
  {
    "objectID": "Plots.html",
    "href": "Plots.html",
    "title": "Plot creation - Camera trap surveys of Atlantic Forest mammals: a dataset for analyses considering imperfect detection (2004-2020)",
    "section": "",
    "text": "The purpose of this document is to guide the datapaper reader toward understanding how we have developed computational codes to generate the descriptive results presented in the datapaper. This initiative was suggested by the editor from Ecology who was responsible to evaluate this paper."
  },
  {
    "objectID": "Plots.html#number-of-camera-trap-surveys-per-year",
    "href": "Plots.html#number-of-camera-trap-surveys-per-year",
    "title": "Plot creation - Camera trap surveys of Atlantic Forest mammals: a dataset for analyses considering imperfect detection (2004-2020)",
    "section": "5.1 Number of camera trap surveys per year",
    "text": "5.1 Number of camera trap surveys per year\nThis code corresponds to Figure 2 in the paper. The aim here was to create a bar graph that illustrates the distribution of 5,380 surveys from 2004 to 2020 within the Atlantic Forest biome.\n\nsurveys |&gt;\n  ggplot2::ggplot(ggplot2::aes(x = year,\n                               stat = \"count\")) + #graph of counting\n  ggplot2::geom_bar() + #graph of bar\n  ggplot2::labs(x = \"Year\",\n                y = \"Surveys\") + #editing the y and x legend\n  ggplot2::scale_y_continuous(expand = c(0, 0),\n                              limits = c(0, 1000)) + #defining the axis y limits and spaces from the borders\n  theme_datapaper()\n\n\n\n\nWe save the plot created using ggplot2::ggsave() function. There is no need to explicitly specify which plot we intend to save, because it defaults to the last generated plot. We configured the plot to be 9 cm in height and 16 cm in width, with a dpi resolution of 320 (‘retina’) using a combination of arguments in the function. The reader ca adjust these values to suit their specific needs. As all the procedures for saving plots are the same, we will not repeat this code throughout the document.\n\nggplot2::ggsave(\n  filename = \"plots/fig2.tiff\",\n  width = 16,\n  height = 9,\n  units = \"cm\",\n  dpi = \"retina\"\n)"
  },
  {
    "objectID": "Plots.html#brands-of-camera-trap",
    "href": "Plots.html#brands-of-camera-trap",
    "title": "Plot creation - Camera trap surveys of Atlantic Forest mammals: a dataset for analyses considering imperfect detection (2004-2020)",
    "section": "5.2 Brands of camera trap",
    "text": "5.2 Brands of camera trap\nThis plot corresponds to Figure 3 in the paper. It was the most complex graph to create because each brand had multiple camera models. To identify the specific pattern of each brand and populate a new column with the brand names, we repeatedly used the stringr::str_detect() function within a dplyr:case_when() statement.\nIn the sequence, we calculated the number of surveys for each camera brand and ordered them in descending order within a column called n_cameraBrand. Because there was a significant difference in the number of camera traps used by different brands, we decided to show the results in two separated plots. The first plot (letter ‘A’) features brands with 100 surveys or more, while the second plot (‘B’) includes all the other brands.\n\ncamera_class &lt;- surveys |&gt;\n  dplyr::mutate(\n    cameraBrand = dplyr::case_when(\n      stringr::str_detect(cameraModel, \"Acorn\") ~ \"Acorn\",\n      stringr::str_detect(cameraModel, \"Amcrest\") ~ \"Amcrest\",\n      stringr::str_detect(cameraModel, \"Apeman\") ~ \"Apeman\",\n      stringr::str_detect(cameraModel, \"Browning\") ~ \"Browning\",\n      stringr::str_detect(cameraModel, \"Bushnell\") ~ \"Bushnell\",\n      stringr::str_detect(cameraModel, \"HDKing\") ~ \"HDKing\",\n      stringr::str_detect(cameraModel, \"Leaf\") ~ \"Leaf River\",\n      stringr::str_detect(cameraModel, \"Moultrie\") ~ \"Moultrie\",\n      stringr::str_detect(cameraModel, \"Reconyx\") ~ \"Reconyx\",\n      stringr::str_detect(cameraModel, \"Scoutguard\") ~ \"Scoutguard\",\n      stringr::str_detect(cameraModel, \"SECACAM\") ~ \"SECACAM\",\n      stringr::str_detect(cameraModel, \"Stealth\") ~ \"Stealth Cam\",\n      stringr::str_detect(cameraModel, \"SunTek\") ~ \"SunTek\",\n      stringr::str_detect(cameraModel, \"Tasco\") ~ \"Tasco\",\n      stringr::str_detect(cameraModel, \"Trail Scan\") ~ \"Trail Scan\",\n      stringr::str_detect(cameraModel, \"Trapa\") ~ \"Trapa Camera\",\n      stringr::str_detect(cameraModel, \"Tigrinus\") ~ \"Tigrinus\",\n      stringr::str_detect(cameraModel, \"Wildgame\") ~ \"Wildgame Innovvations\",\n      stringr::str_detect(cameraModel, \"homemade\") ~ \"homemade\",\n      TRUE ~ cameraModel\n    )\n  ) |&gt;\n  dplyr::count(cameraBrand,\n               sort = TRUE,\n               name = \"n_cameraBrand\") |&gt; # tallying by camera model, ordering descending\n  dplyr::mutate(cameraBrand = forcats::as_factor(cameraBrand), #setting as factor to keep order\n                fig = dplyr::if_else(n_cameraBrand &gt;= 100, \"A\", \"B\") #identifying camera model with more than 100 records as 'A' and less as 'B'\n  )\n\ncamera_class\n\n# A tibble: 22 × 3\n   cameraBrand    n_cameraBrand fig  \n   &lt;fct&gt;                  &lt;int&gt; &lt;chr&gt;\n 1 Bushnell                3400 A    \n 2 Tigrinus                 763 A    \n 3 Reconyx                  338 A    \n 4 Acorn                    249 A    \n 5 Trapa Camera             102 A    \n 6 Browning                  82 B    \n 7 Moultrie                  72 B    \n 8 SunTek                    66 B    \n 9 Ecotone                   40 B    \n10 Olho-de-coruja            38 B    \n# ℹ 12 more rows\n\n\nThen, we created two new objects, namely ‘camera_figA’ and ‘camera_figB’, one for each figure. We did this by filtering the data based on the respective letter. Next, we created a ggplot2 graph for each letter, which we named ‘fig3A’ and ‘fig3B’. Finally, we used the patchwork package to arrange the graphs on top of each other using the / operator. Note that to use the patchwork package in this context, you must first load the package into memory by running library(patchwork).\n\n# Filtering camera brands by letter\ncamera_figA &lt;- camera_class |&gt;\n  dplyr::filter(fig == \"A\")\n\ncamera_figB &lt;- camera_class |&gt;\n  dplyr::filter(fig == \"B\")\n\n# Creating ggplot graphs for each letter\nfig3A &lt;- camera_figA |&gt;\n  ggplot2::ggplot() + #plotting the camera models most used\n  ggplot2::geom_col(ggplot2::aes(x = cameraBrand,\n                                 y = n_cameraBrand)) + #organizing the camera model by counting\n  ggplot2::labs(x = NULL,\n                y = \"Surveys\") + #identifying the axis y as the axis of surveys\n  ggplot2::scale_y_continuous(\n    expand = c(0, 0),\n    limits = c(0, 3500),\n    breaks = seq(0, 3500, by = 500)\n  ) + #defining the axis y breaks, limits and spaces from the borders\n  theme_datapaper()\n\nfig3B &lt;- camera_figB |&gt;\n  ggplot2::ggplot() + #plotting the camera models less used\n  ggplot2::geom_col(ggplot2::aes(x = cameraBrand,\n                                 y = n_cameraBrand)) + #organizing the camera model by counting\n  ggplot2::labs(x = \"Camera brand\",\n                y = \"Surveys\") + #identifying the axis y as the axis of surveys\n  ggplot2::scale_y_continuous(\n    expand = c(0, 0),\n    limits = c(0, 100),\n    breaks = seq(0, 100, by = 20)\n  ) + #defining the axis y breaks, limits and spaces from the borders\n  theme_datapaper() +\n  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45,\n                                                     hjust = 1))\n\n# Assembling the plots with patchwork\nfig3A / fig3B +\n  patchwork::plot_annotation(tag_levels = \"A\")"
  },
  {
    "objectID": "Plots.html#sec-taxa_500",
    "href": "Plots.html#sec-taxa_500",
    "title": "Plot creation - Camera trap surveys of Atlantic Forest mammals: a dataset for analyses considering imperfect detection (2004-2020)",
    "section": "5.3 Taxa greater (or equal) than 500 records",
    "text": "5.3 Taxa greater (or equal) than 500 records\nThe following plots is not included in the paper. The purpose of this plot is to show the most frequently recorded species, filtered to include only those with 500 or more records. To properly render the scientific names in italics, we applied a workaround using Markdown notation. To make the axis text italic for species names, we implemented a rule: if the second word in the scientific name was ‘sp.’, it would apply underscores (_) only to the first word. However, if the second word was not ‘sp.’, then the entire scientific name should be enclosed in underscores. In Markdown notation, underscores italicize the enclosed text. To ensure ggplot recognize the underscores as Markdown, we used the ggtext::element_markdown() function.\n\nrecords |&gt;\n  dplyr::count(scientificName, sort = TRUE) |&gt; #counting in the record file the record number of each species\n  dplyr::filter(n &gt;= 500) |&gt;\n  dplyr::mutate(scientificName = dplyr::if_else(condition = stringr::word(scientificName, 2, 2) == \"sp.\",\n                                                true = sprintf(\"_%s_ %s\", stringr::word(scientificName, 1, 1),\n                                                               stringr::word(scientificName, 2, 2)),\n                                                false = sprintf(\"_%s_\", scientificName)),\n                scientificName = forcats::as_factor(scientificName)) |&gt;  #setting scientificName as a factor with the current ordering\n  ggplot2::ggplot() +\n  ggplot2::geom_col(ggplot2::aes(x = scientificName, y = n)) +\n  ggplot2::scale_y_continuous(\n    expand = ggplot2::expansion(mult = 0),\n    limits = c(0, 6500),\n    breaks = seq(0, 6500, by = 500)\n  ) + #defining the axis y breaks, limits and spaces from the borders\n  ggplot2::labs(x = NULL,\n                y = \"Records\") + #identifying the axis y as the axis of records\n  ggplot2::coord_flip() + #changing the axis y and x\n  theme_datapaper() +\n  ggplot2::theme(\n    plot.margin = ggplot2::margin(t = 5,\n                                  r = 10,\n                                  b = 5,\n                                  l = 5,\n                                  unit = \"pt\"), #to exhibit the flipped axis y text\n    axis.text.y = ggtext::element_markdown()\n  )"
  },
  {
    "objectID": "Plots.html#taxa-recorded-in-more-than-100-surveys",
    "href": "Plots.html#taxa-recorded-in-more-than-100-surveys",
    "title": "Plot creation - Camera trap surveys of Atlantic Forest mammals: a dataset for analyses considering imperfect detection (2004-2020)",
    "section": "5.4 Taxa recorded in more than 100 surveys",
    "text": "5.4 Taxa recorded in more than 100 surveys\nThe plot of the following code is not included in the paper. The purpose of this plot is to show the most frequently recorded species, considering the surveys as sample unit and filtering for those with 100 or more records. We used the same method to italicize the scientific names as in Section 5.3.\n\nrecords |&gt;\n  dplyr::distinct(scientificName, surveyId) |&gt;\n  dplyr::count(scientificName, sort = TRUE) |&gt;\n  dplyr::filter(n &gt;= 100) |&gt;\n  dplyr::mutate(scientificName = dplyr::if_else(\n    condition = stringr::word(scientificName, 2, 2) == \"sp.\", #to make axis text italic for species names using Markdown notation\n    true = sprintf(\"_%s_ %s\", stringr::word(scientificName, 1, 1), #use italic just in the first word\n                   stringr::word(scientificName, 2, 2)),\n    false = sprintf(\"_%s_\", scientificName)\n  ), #otherwise, use italic in full name\n  scientificName = forcats::as_factor(scientificName)) |&gt; #setting scientificName as a factor\n  ggplot2::ggplot() +\n  ggplot2::geom_col(ggplot2::aes(x = scientificName, y = n)) + #organizing the scientific name\n  ggplot2::scale_y_continuous(\n    expand = ggplot2::expansion(mult = 0),\n    limits = c(0, 1500),\n    breaks = seq(0, 1500, by = 500)\n  ) + #defining the axis y breaks, limits and spaces from the borders\n  ggplot2::labs(x = NULL,\n                y = \"Surveys\") + #identifying the axis y as the axis of surveys\n  ggplot2::coord_flip() + #changing the axis y and x position\n  theme_datapaper() +\n  ggplot2::theme(\n    plot.margin = ggplot2::margin(t = 5,\n                                  r = 10,\n                                  b = 5,\n                                  l = 5,\n                                  unit = \"pt\"), #to exhibit the flipped axis y text\n    axis.text.y = ggtext::element_markdown() #to make axis text italic for species names\n  )"
  },
  {
    "objectID": "Plots.html#taxa-recorded-in-more-than-100-camera-locations",
    "href": "Plots.html#taxa-recorded-in-more-than-100-camera-locations",
    "title": "Plot creation - Camera trap surveys of Atlantic Forest mammals: a dataset for analyses considering imperfect detection (2004-2020)",
    "section": "5.5 Taxa recorded in more than 100 camera locations",
    "text": "5.5 Taxa recorded in more than 100 camera locations\nThe plot of the following code is not included in the paper. The purpose of this plot is to show the distribution of taxa across the locations where cameras were installed throughout our dataset. To do this, we first joined the surveys and records tables on the surveyId column, because the fields of interest, locationId and scientificName, were in different tables. Each locationId consists in a pair of coordinates, and then it was used in the distinct function together with the scientificName field. After that, we counted how many times each scientific name appeared and filtered the NA (because we had some locationId did not have any species) and the species which the count sum was equal or greater than 100. All the specifics concerning italicizing were already described in Section 5.3.\n\nsurveys |&gt;\n  dplyr::left_join(records, by = \"surveyId\") |&gt;\n  dplyr::distinct(locationId, scientificName) |&gt;\n  dplyr::count(scientificName, sort = TRUE) |&gt;\n  dplyr::filter(!is.na(scientificName),\n                n &gt;= 100) |&gt;\n  dplyr::mutate(scientificName = dplyr::if_else(\n    condition = stringr::word(scientificName, 2, 2) == \"sp.\",\n    true = sprintf(\"_%s_ %s\", stringr::word(scientificName, 1, 1),                    stringr::word(scientificName, 2, 2)),\n    false = sprintf(\"_%s_\", scientificName)\n  ),\n  scientificName = forcats::as_factor(scientificName)) |&gt;\n  ggplot2::ggplot() +\n  ggplot2::geom_col(ggplot2::aes(x = scientificName, y = n)) +\n  ggplot2::scale_y_continuous(\n    expand = ggplot2::expansion(mult = 0),\n    limits = c(0, 1100),\n    breaks = seq(0, 1100, by = 100)\n  ) +\n  ggplot2::labs(x = NULL,\n                y = \"Locations\") +\n  ggplot2::coord_flip() +\n  theme_datapaper() +\n  ggplot2::theme(\n    plot.margin = ggplot2::margin(t = 5,\n                                  r = 10,\n                                  b = 5,\n                                  l = 5,\n                                  unit = \"pt\"),\n    axis.text.y = ggtext::element_markdown()\n  )"
  },
  {
    "objectID": "Plots.html#surveys-duration-in-days",
    "href": "Plots.html#surveys-duration-in-days",
    "title": "Plot creation - Camera trap surveys of Atlantic Forest mammals: a dataset for analyses considering imperfect detection (2004-2020)",
    "section": "5.6 Surveys’ duration in days",
    "text": "5.6 Surveys’ duration in days\nThe plot of the following code is not included in the paper. We were interested in having a histogram-like plot to check the duration of the surveys. However, most of the surveys were less than 100 days long, so the surveys with longer durations were nearly invisible in the generated graphs.\nTo address this issue, we decided to apply a Fisher-Jenks approach to segment the survey durations into classes so that the data could be better visualized and interpreted. Fisher-Jenks is a popular method for data segmentation into statistically derived classes, so that the variation between classes is maximized and the variation within classes is minimized. We used the classIntervals function from the classInt package to segment the data into classes, using the argument style = \"fisher\". We decided to divide the data into 20 groups (n = 20) and set dataPrecision = 0 because we are dealing with integers (number of days). The output of the processing is a table of the groups, comprising the minimum and the maximum number of days inside an open square bracket (≥) and a closing parenthesis (&lt;), and the count for each group. To make this table available for further steps, we saved it in a new object using a hack with print and []. After this, we simply had to call it as a data frame and rename the columns.\n\nintervals &lt;- classInt::classIntervals(\n  var = surveys$surveyDays,\n  n = 20,\n  style = \"fisher\",\n  dataPrecision = 0,\n  cutlabels = FALSE,\n  between = \"-\"\n)\n\nclass_results &lt;- print(intervals)[] |&gt;\n  as.data.frame() |&gt;\n  setNames(c(\"value\", \"n\"))\n\nstyle: fisher\n     [1,11)     [11,19)     [19,28)     [28,41)     [41,57)     [57,76) \n       1451         870         632         995         329         374 \n    [76,99)    [99,122)   [122,145)   [145,174)   [174,210)   [210,253) \n        211         140          99          75          68          29 \n  [253,298)   [298,344)   [344,399)   [399,551)   [551,763)   [763,986) \n         28          18          36          12           6           4 \n [986,1321) [1321,1558] \n          1           2 \n\n# Calling the results after transforming to data frame\nclass_results\n\n         value    n\n1       [1,11) 1451\n2      [11,19)  870\n3      [19,28)  632\n4      [28,41)  995\n5      [41,57)  329\n6      [57,76)  374\n7      [76,99)  211\n8     [99,122)  140\n9    [122,145)   99\n10   [145,174)   75\n11   [174,210)   68\n12   [210,253)   29\n13   [253,298)   28\n14   [298,344)   18\n15   [344,399)   36\n16   [399,551)   12\n17   [551,763)    6\n18   [763,986)    4\n19  [986,1321)    1\n20 [1321,1558]    2\n\n\nWe now need to create a new column to set the frequency of each class. This is done to ensure that the maximum value on the y-axis is not too high, so that even classes with a small share of the duration will be visible on the graph.\n\nclass_results |&gt;\n  dplyr::mutate(freq = n / sum(n) * 100) |&gt;\n  ggplot2::ggplot(ggplot2::aes(x = value, y = freq)) +\n  ggplot2::geom_col() +\n  ggplot2::labs(x = \"Duration of survey in days\",\n                y = \"%\") +\n  ggplot2::scale_y_continuous(\n    expand = ggplot2::expansion(mult = c(.0025, 0)),\n    limits = c(0, 30),\n    breaks = seq(0, 30, 5)\n  ) +\n  theme_datapaper() +\n  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45,\n                                                     hjust = 1))"
  }
]